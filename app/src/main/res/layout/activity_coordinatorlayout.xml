<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:id="@+id/main_content"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:fitsSystemWindows="true">
    <!--    <androidx.recyclerview.widget.RecyclerView-->
    <!--            android:id="@+id/rvToDoList"-->
    <!--            android:layout_width="match_parent"-->
    <!--            android:layout_height="match_parent"-->
    <!--            app:layout_behavior="@string/appbar_scrolling_view_behavior"/>-->


    <com.google.android.material.appbar.AppBarLayout
            android:layout_width="match_parent"
            android:layout_height="200dp">

        <com.google.android.material.appbar.CollapsingToolbarLayout
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                app:layout_scrollFlags="scroll|exitUntilCollapsed">
            <ImageView
                    android:layout_width="match_parent"
                    android:layout_height="match_parent"
                    android:background="@mipmap/ic_launcher"/>
            <androidx.appcompat.widget.Toolbar
                    android:id="@+id/toolbar"
                    app:layout_collapseMode="pin"
                    android:layout_width="match_parent"
                    android:layout_height="?attr/actionBarSize"
                    android:background="?attr/colorPrimary"
                    app:title="Title" />
        </com.google.android.material.appbar.CollapsingToolbarLayout>

    </com.google.android.material.appbar.AppBarLayout>

    <androidx.core.widget.NestedScrollView
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            app:layout_behavior="@string/appbar_scrolling_view_behavior">

        <TextView
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:text="welcome to the co-routines codelab ,in this codelab you will learn the basics of using kotlin co-routines and android apps to perform things like network request. we put this video together as a quick introduction to co-routines . on kotlin if you already know them from another language feel free to skip it and go straight into the codelab. co-routines are a new feature in kotlin but they're actually a pretty old concept they've been used in popular languages for the last few decades and they turn out to be a great solution to some common problems that we have on android co-routines allow you to replace callbacks you can transform callback style into what's called sequential. programming in this video wo'll explore how they do that. in addition to replace callbacks on android they also give us the ability to make our code main safe and this means you can write co-routine base functions to make a network request for example and just call it from the main thread and everything will be okay. so let's write some code to make imaginary network request to make this interesting let's start it on the main thread if we write it in what's called a blocking style where wu return the result directly from the network request it will block the main thread this is a probleam because a network request may take seconds or even minutes to complete and the entire time that it's running the mian thread won't get updates or respond to touch and the user will see your app as frozen this is a really bad experience for the user and wo don't want to do that on android if instead we write the same function with callbacks now our code won't block our networking library we'll take care of running the network request on another thread and when the data is ready it will pass the data or call back to the main thread the callback is the handle the library uses to pass data from the background thread to the main thread while callbacks are a greate solution to async programming they come with a few issuses they don't handle air as well without doing more work and they become overwhelming when too many callbacks are used in the same function to solve these issues we can use co-routines here's the sacme function written with co-routines . to make it work with co-routines it becomes a suspend function it  looks just like it did when it was a blocking function however since it's a suspend function instead of blocking the main thread when network request is called it will suspend the co-routine this frees up the main thread to handle on draw and user touches and when the result is ready it'll get passed back instead of useing a callback the co-routine wi resume. now it's important to note that with co-routines our networking library still uses another thread to run the network request just like it did with callbacks the main difference is the code tends to be simpler than the callback version now you can think about suspend and resume as replacing callbacks so when you call network requests suspend makes a callback from the rest of the function so how does kotion do that. let's take a look at how it executes when kotin executes on data needed it will execute it a bit differently on the call statck than a normal function it keeps track of the place it starts the co-routines so that can implement suspend and resume then it will call it just like a normal function executing each line of code untill it reaches a call to another suspend function before it calls the suspend function it will copy the current state for later and that's how kotlin implements suspend you can think of this state as a callback that knows how to resume the current function then kotlin will run network requests until it suspends itself to make the network call now at this point all of the co-routines on main are suspended so main is free to handle ui events fase forward a bit until the network request comes back and kotion will resume these co-routines first it'l resume network requests as it does this by restoring the state it's saved earlier once request is done processing the request it'll return to on data needed and the result is available immediately if the network request failed it would throw an exception right here instead then the co-routine will continue executing just like a normal function until it returns because co-routines allow us to handle long running tasks without introducing callbacks they tend to create simpler more readable code in the rest of this codelab you'll explore how to integrate co-routine with arc components to make a network request we'll also touch upon how to make code main safe and with that let's suspend this video and resume the codelab welcome to the co-routines codelab ,in this codelab you will learn the basics of using kotlin co-routines and android apps to perform things like network request. we put this video together as a quick introduction to co-routines . on kotlin if you already know them from another language feel free to skip it and go straight into the codelab. co-routines are a new feature in kotlin but they're actually a pretty old concept they've been used in popular languages for the last few decades and they turn out to be a great solution to some common problems that we have on android co-routines allow you to replace callbacks you can transform callback style into what's called sequential. programming in this video wo'll explore how they do that. in addition to replace callbacks on android they also give us the ability to make our code main safe and this means you can write co-routine base functions to make a network request for example and just call it from the main thread and everything will be okay. so let's write some code to make imaginary network request to make this interesting let's start it on the main thread if we write it in what's called a blocking style where wu return the result directly from the network request it will block the main thread this is a probleam because a network request may take seconds or even minutes to complete and the entire time that it's running the mian thread won't get updates or respond to touch and the user will see your app as frozen this is a really bad experience for the user and wo don't want to do that on android if instead we write the same function with callbacks now our code won't block our networking library we'll take care of running the network request on another thread and when the data is ready it will pass the data or call back to the main thread the callback is the handle the library uses to pass data from the background thread to the main thread while callbacks are a greate solution to async programming they come with a few issuses they don't handle air as well without doing more work and they become overwhelming when too many callbacks are used in the same function to solve these issues we can use co-routines here's the sacme function written with co-routines . to make it work with co-routines it becomes a suspend function it  looks just like it did when it was a blocking function however since it's a suspend function instead of blocking the main thread when network request is called it will suspend the co-routine this frees up the main thread to handle on draw and user touches and when the result is ready it'll get passed back instead of useing a callback the co-routine wi resume. now it's important to note that with co-routines our networking library still uses another thread to run the network request just like it did with callbacks the main difference is the code tends to be simpler than the callback version now you can think about suspend and resume as replacing callbacks so when you call network requests suspend makes a callback from the rest of the function so how does kotion do that. let's take a look at how it executes when kotin executes on data needed it will execute it a bit differently on the call statck than a normal function it keeps track of the place it starts the co-routines so that can implement suspend and resume then it will call it just like a normal function executing each line of code untill it reaches a call to another suspend function before it calls the suspend function it will copy the current state for later and that's how kotlin implements suspend you can think of this state as a callback that knows how to resume the current function then kotlin will run network requests until it suspends itself to make the network call now at this point all of the co-routines on main are suspended so main is free to handle ui events fase forward a bit until the network request comes back and kotion will resume these co-routines first it'l resume network requests as it does this by restoring the state it's saved earlier once request is done processing the request it'll return to on data needed and the result is available immediately if the network request failed it would throw an exception right here instead then the co-routine will continue executing just like a normal function until it returns because co-routines allow us to handle long running tasks without introducing callbacks they tend to create simpler more readable code in the rest of this codelab you'll explore how to integrate co-routine with arc components to make a network request we'll also touch upon how to make code main safe and with that let's suspend this video and resume the codelab welcome to the co-routines codelab ,in this codelab you will learn the basics of using kotlin co-routines and android apps to perform things like network request. we put this video together as a quick introduction to co-routines . on kotlin if you already know them from another language feel free to skip it and go straight into the codelab. co-routines are a new feature in kotlin but they're actually a pretty old concept they've been used in popular languages for the last few decades and they turn out to be a great solution to some common problems that we have on android co-routines allow you to replace callbacks you can transform callback style into what's called sequential. programming in this video wo'll explore how they do that. in addition to replace callbacks on android they also give us the ability to make our code main safe and this means you can write co-routine base functions to make a network request for example and just call it from the main thread and everything will be okay. so let's write some code to make imaginary network request to make this interesting let's start it on the main thread if we write it in what's called a blocking style where wu return the result directly from the network request it will block the main thread this is a probleam because a network request may take seconds or even minutes to complete and the entire time that it's running the mian thread won't get updates or respond to touch and the user will see your app as frozen this is a really bad experience for the user and wo don't want to do that on android if instead we write the same function with callbacks now our code won't block our networking library we'll take care of running the network request on another thread and when the data is ready it will pass the data or call back to the main thread the callback is the handle the library uses to pass data from the background thread to the main thread while callbacks are a greate solution to async programming they come with a few issuses they don't handle air as well without doing more work and they become overwhelming when too many callbacks are used in the same function to solve these issues we can use co-routines here's the sacme function written with co-routines . to make it work with co-routines it becomes a suspend function it  looks just like it did when it was a blocking function however since it's a suspend function instead of blocking the main thread when network request is called it will suspend the co-routine this frees up the main thread to handle on draw and user touches and when the result is ready it'll get passed back instead of useing a callback the co-routine wi resume. now it's important to note that with co-routines our networking library still uses another thread to run the network request just like it did with callbacks the main difference is the code tends to be simpler than the callback version now you can think about suspend and resume as replacing callbacks so when you call network requests suspend makes a callback from the rest of the function so how does kotion do that. let's take a look at how it executes when kotin executes on data needed it will execute it a bit differently on the call statck than a normal function it keeps track of the place it starts the co-routines so that can implement suspend and resume then it will call it just like a normal function executing each line of code untill it reaches a call to another suspend function before it calls the suspend function it will copy the current state for later and that's how kotlin implements suspend you can think of this state as a callback that knows how to resume the current function then kotlin will run network requests until it suspends itself to make the network call now at this point all of the co-routines on main are suspended so main is free to handle ui events fase forward a bit until the network request comes back and kotion will resume these co-routines first it'l resume network requests as it does this by restoring the state it's saved earlier once request is done processing the request it'll return to on data needed and the result is available immediately if the network request failed it would throw an exception right here instead then the co-routine will continue executing just like a normal function until it returns because co-routines allow us to handle long running tasks without introducing callbacks they tend to create simpler more readable code in the rest of this codelab you'll explore how to integrate co-routine with arc components to make a network request we'll also touch upon how to make code main safe and with that let's suspend this video and resume the codelab" />
    </androidx.core.widget.NestedScrollView>

    <com.google.android.material.floatingactionbutton.FloatingActionButton
            android:id="@+id/floating_action_btn"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="right|bottom"
            android:layout_marginRight="10dp"
            android:layout_marginBottom="10dp"
            app:borderWidth="0dp"
            app:fabSize="normal" />

</androidx.coordinatorlayout.widget.CoordinatorLayout>